"""
AI Image Filter - Detects and sorts AI-generated images based on metadata
"""

import os
import shutil
import struct
import zlib
from pathlib import Path
from typing import Optional
from dataclasses import dataclass

# Try to import PIL for EXIF data
try:
    from PIL import Image
    from PIL.ExifTags import TAGS
    PIL_AVAILABLE = True
except ImportError:
    PIL_AVAILABLE = False
    print("Warning: Pillow not installed. Install with: pip install Pillow")
    print("Some metadata detection features will be limited.\n")


# Known AI tool signatures to look for in metadata
AI_SIGNATURES = [
    # Stable Diffusion / ComfyUI / A1111
    "stable diffusion",
    "stablediffusion", 
    "sd_model",
    "comfyui",
    "comfy",
    "automatic1111",
    "a1111",
    "invokeai",
    "novelai",
    "nai diffusion",
    "dreamstudio",
    "stability.ai",
    "sdxl",
    "sd 1.5",
    "sd 2.1",
    "flux",
    
    # Generation parameters (common in SD)
    "cfg scale",
    "cfg_scale",
    "sampler:",
    "steps:",
    "seed:",
    "negative prompt",
    "lora:",
    "embedding:",
    "checkpoint:",
    "vae:",
    "clip skip",
    
    # DALL-E / OpenAI
    "dall-e",
    "dalle",
    "openai",
    
    # Midjourney
    "midjourney",
    "mj",
    "--ar ",  # Midjourney aspect ratio flag
    "--v ",   # Midjourney version flag
    
    # Other AI tools
    "leonardo.ai",
    "leonardo ai",
    "bing image creator",
    "copilot designer",
    "adobe firefly",
    "firefly",
    "runway",
    "nightcafe",
    "artbreeder",
    "deepai",
    "starryai",
    "craiyon",
    "wombo dream",
    "jasper art",
    "getimg.ai",
    "playground ai",
    "dreamlike",
    "lexica",
    "prompthero",
    
    # Generic AI indicators
    "ai generated",
    "ai-generated",
    "generated by ai",
    "created with ai",
    "text2image",
    "text-to-image",
    "txt2img",
    "img2img",
    "inpainting",
    "controlnet",
    "lora",
    "dreambooth",
    
    # Model names
    "realistic vision",
    "deliberate",
    "counterfeit",
    "anything v",
    "dreamshaper",
    "protogen",
    "basil mix",
    "abyss orange",
    "majicmix",
    "chilloutmix",
    "meinamix",
]

# File extensions to process
IMAGE_EXTENSIONS = {'.png', '.jpg', '.jpeg', '.webp', '.gif', '.bmp', '.tiff', '.tif'}


@dataclass
class ScanResult:
    """Result of scanning an image for AI signatures"""
    filepath: Path
    is_ai: bool
    confidence: str  # "high", "medium", "low", "none"
    detected_signatures: list
    metadata_source: str  # Where the signature was found


def read_png_chunks(filepath: Path) -> dict:
    """
    Read PNG text chunks directly - this is where Stable Diffusion 
    stores generation parameters
    """
    chunks = {}
    
    try:
        with open(filepath, 'rb') as f:
            # Check PNG signature
            signature = f.read(8)
            if signature != b'\x89PNG\r\n\x1a\n':
                return chunks
            
            while True:
                # Read chunk header
                chunk_header = f.read(8)
                if len(chunk_header) < 8:
                    break
                    
                length = struct.unpack('>I', chunk_header[:4])[0]
                chunk_type = chunk_header[4:8].decode('ascii', errors='ignore')
                
                # Read chunk data
                chunk_data = f.read(length)
                
                # Read CRC
                f.read(4)
                
                # Text chunks contain metadata
                if chunk_type in ('tEXt', 'iTXt', 'zTXt'):
                    try:
                        if chunk_type == 'tEXt':
                            # Simple text: keyword\0text
                            null_pos = chunk_data.find(b'\x00')
                            if null_pos != -1:
                                key = chunk_data[:null_pos].decode('latin-1')
                                value = chunk_data[null_pos+1:].decode('latin-1', errors='ignore')
                                chunks[key] = value
                                
                        elif chunk_type == 'zTXt':
                            # Compressed text: keyword\0compression_method\0compressed_text
                            null_pos = chunk_data.find(b'\x00')
                            if null_pos != -1:
                                key = chunk_data[:null_pos].decode('latin-1')
                                # Skip compression method byte
                                compressed = chunk_data[null_pos+2:]
                                try:
                                    value = zlib.decompress(compressed).decode('utf-8', errors='ignore')
                                    chunks[key] = value
                                except:
                                    pass
                                    
                        elif chunk_type == 'iTXt':
                            # International text - more complex
                            null_pos = chunk_data.find(b'\x00')
                            if null_pos != -1:
                                key = chunk_data[:null_pos].decode('utf-8', errors='ignore')
                                # Parse the rest (compression flag, method, language, translated keyword, text)
                                rest = chunk_data[null_pos+1:]
                                if len(rest) >= 2:
                                    compression_flag = rest[0]
                                    # Find the text after null terminators
                                    parts = rest[2:].split(b'\x00', 2)
                                    if len(parts) >= 3:
                                        text = parts[2]
                                        if compression_flag:
                                            try:
                                                text = zlib.decompress(text)
                                            except:
                                                pass
                                        chunks[key] = text.decode('utf-8', errors='ignore') if isinstance(text, bytes) else text
                    except Exception:
                        pass
                        
                # IEND marks end of PNG
                if chunk_type == 'IEND':
                    break
                    
    except Exception as e:
        pass
        
    return chunks


def get_exif_data(filepath: Path) -> dict:
    """Extract EXIF metadata from image using PIL"""
    exif_data = {}
    
    if not PIL_AVAILABLE:
        return exif_data
        
    try:
        with Image.open(filepath) as img:
            # Get standard EXIF
            exif = img._getexif()
            if exif:
                for tag_id, value in exif.items():
                    tag = TAGS.get(tag_id, tag_id)
                    if isinstance(value, bytes):
                        value = value.decode('utf-8', errors='ignore')
                    exif_data[str(tag)] = str(value)
            
            # Get PNG info (where SD stores data)
            if hasattr(img, 'info'):
                for key, value in img.info.items():
                    if isinstance(value, bytes):
                        value = value.decode('utf-8', errors='ignore')
                    exif_data[f"PNG:{key}"] = str(value)
                    
            # Get XMP data if available
            if hasattr(img, 'applist'):
                for segment, content in img.applist:
                    if segment == 'APP1' and b'http://ns.adobe.com/xap/' in content:
                        exif_data['XMP'] = content.decode('utf-8', errors='ignore')
                        
    except Exception as e:
        pass
        
    return exif_data


def check_for_ai_signatures(metadata: dict, filepath: Path) -> ScanResult:
    """Check metadata for AI generation signatures"""
    detected = []
    sources = []
    
    # Combine all metadata values into searchable text
    all_text = ""
    for key, value in metadata.items():
        text = f"{key}: {value}".lower()
        all_text += text + "\n"
        
        # Check each signature
        for signature in AI_SIGNATURES:
            if signature.lower() in text:
                detected.append(signature)
                sources.append(key)
    
    # Special checks for specific patterns
    
    # Check for "parameters" key (A1111/ComfyUI specific)
    if any(key.lower() in ['parameters', 'png:parameters', 'prompt'] for key in metadata.keys()):
        if 'parameters' not in detected:
            detected.append('parameters metadata key')
            sources.append('PNG chunk')
    
    # Check for workflow JSON (ComfyUI specific)
    if any('workflow' in key.lower() for key in metadata.keys()):
        detected.append('comfyui workflow')
        sources.append('PNG metadata')
    
    # Check for prompt/negative prompt structure
    if 'negative prompt' in all_text or 'negative:' in all_text:
        if 'negative prompt' not in detected:
            detected.append('negative prompt structure')
            sources.append('metadata')
    
    # Determine confidence
    unique_detected = list(set(detected))
    
    if len(unique_detected) >= 3:
        confidence = "high"
    elif len(unique_detected) == 2:
        confidence = "medium"
    elif len(unique_detected) == 1:
        confidence = "low"
    else:
        confidence = "none"
    
    is_ai = confidence != "none"
    
    return ScanResult(
        filepath=filepath,
        is_ai=is_ai,
        confidence=confidence,
        detected_signatures=unique_detected,
        metadata_source=", ".join(set(sources)) if sources else "none"
    )


def scan_image(filepath: Path) -> ScanResult:
    """Scan a single image for AI signatures"""
    metadata = {}
    
    # Read PNG chunks directly (most reliable for SD images)
    if filepath.suffix.lower() == '.png':
        png_chunks = read_png_chunks(filepath)
        for key, value in png_chunks.items():
            metadata[f"PNG:{key}"] = value
    
    # Get EXIF data
    exif_data = get_exif_data(filepath)
    metadata.update(exif_data)
    
    return check_for_ai_signatures(metadata, filepath)


def scan_folder(source_folder: str, verbose: bool = True) -> list[ScanResult]:
    """Scan all images in a folder"""
    source_path = Path(source_folder)
    results = []
    
    if not source_path.exists():
        print(f"Error: Source folder does not exist: {source_folder}")
        return results
    
    # Find all image files
    image_files = []
    for ext in IMAGE_EXTENSIONS:
        image_files.extend(source_path.glob(f"*{ext}"))
        image_files.extend(source_path.glob(f"*{ext.upper()}"))
    
    total = len(image_files)
    if verbose:
        print(f"Found {total} images to scan...")
    
    for i, filepath in enumerate(image_files, 1):
        if verbose and i % 10 == 0:
            print(f"  Scanning {i}/{total}...")
            
        result = scan_image(filepath)
        results.append(result)
    
    return results


def filter_ai_images(
    source_folder: str,
    ai_destination: str,
    move: bool = True,
    recursive: bool = False,
    min_confidence: str = "low",
    verbose: bool = True
) -> dict:
    """
    Main function to filter AI images from a folder
    
    Args:
        source_folder: Folder to scan for images
        ai_destination: Folder to move/copy AI images to
        move: True to move files, False to copy
        recursive: Scan subfolders recursively
        min_confidence: Minimum confidence level to consider ("low", "medium", "high")
        verbose: Print progress information
    
    Returns:
        Dictionary with statistics about the operation
    """
    source_path = Path(source_folder)
    dest_path = Path(ai_destination)
    
    # Validate paths
    if not source_path.exists():
        print(f"Error: Source folder does not exist: {source_folder}")
        return {}
    
    # Create destination if it doesn't exist
    dest_path.mkdir(parents=True, exist_ok=True)
    
    # Confidence levels
    confidence_levels = {"high": 3, "medium": 2, "low": 1, "none": 0}
    min_level = confidence_levels.get(min_confidence.lower(), 1)
    
    # Find all image files
    image_files = []
    if recursive:
        for ext in IMAGE_EXTENSIONS:
            image_files.extend(source_path.rglob(f"*{ext}"))
            image_files.extend(source_path.rglob(f"*{ext.upper()}"))
    else:
        for ext in IMAGE_EXTENSIONS:
            image_files.extend(source_path.glob(f"*{ext}"))
            image_files.extend(source_path.glob(f"*{ext.upper()}"))
    
    # Remove duplicates (case-insensitive extensions might cause this)
    image_files = list(set(image_files))
    
    total = len(image_files)
    if verbose:
        print(f"\n{'='*60}")
        print(f"AI Image Filter")
        print(f"{'='*60}")
        print(f"Source: {source_folder}")
        print(f"AI Destination: {ai_destination}")
        print(f"Mode: {'Move' if move else 'Copy'}")
        print(f"Minimum Confidence: {min_confidence}")
        print(f"{'='*60}")
        print(f"\nFound {total} images to scan...")
    
    # Statistics
    stats = {
        "total_scanned": total,
        "ai_detected": 0,
        "ai_high": 0,
        "ai_medium": 0,
        "ai_low": 0,
        "normal": 0,
        "errors": 0,
        "files_moved": [],
        "files_kept": [],
    }
    
    for i, filepath in enumerate(image_files, 1):
        if verbose and (i % 25 == 0 or i == total):
            print(f"  Progress: {i}/{total} ({100*i//total}%)")
        
        try:
            result = scan_image(filepath)
            conf_level = confidence_levels.get(result.confidence, 0)
            
            if result.is_ai and conf_level >= min_level:
                # This is an AI image, move/copy it
                stats["ai_detected"] += 1
                
                if result.confidence == "high":
                    stats["ai_high"] += 1
                elif result.confidence == "medium":
                    stats["ai_medium"] += 1
                else:
                    stats["ai_low"] += 1
                
                # Determine destination path
                dest_file = dest_path / filepath.name
                
                # Handle name conflicts
                counter = 1
                while dest_file.exists():
                    stem = filepath.stem
                    dest_file = dest_path / f"{stem}_{counter}{filepath.suffix}"
                    counter += 1
                
                # Move or copy
                if move:
                    shutil.move(str(filepath), str(dest_file))
                else:
                    shutil.copy2(str(filepath), str(dest_file))
                
                stats["files_moved"].append({
                    "original": str(filepath),
                    "destination": str(dest_file),
                    "confidence": result.confidence,
                    "signatures": result.detected_signatures[:5]  # Limit for readability
                })
                
                if verbose:
                    action = "Moved" if move else "Copied"
                    print(f"    [{result.confidence.upper()}] {action}: {filepath.name}")
                    
            else:
                stats["normal"] += 1
                stats["files_kept"].append(str(filepath))
                
        except Exception as e:
            stats["errors"] += 1
            if verbose:
                print(f"    Error processing {filepath.name}: {e}")
    
    # Print summary
    if verbose:
        print(f"\n{'='*60}")
        print(f"SUMMARY")
        print(f"{'='*60}")
        print(f"Total images scanned: {stats['total_scanned']}")
        print(f"AI images detected: {stats['ai_detected']}")
        print(f"  - High confidence: {stats['ai_high']}")
        print(f"  - Medium confidence: {stats['ai_medium']}")
        print(f"  - Low confidence: {stats['ai_low']}")
        print(f"Normal images: {stats['normal']}")
        print(f"Errors: {stats['errors']}")
        print(f"{'='*60}\n")
    
    return stats


def main():
    """Interactive mode for the AI filter"""
    print("\n" + "="*60)
    print("  AI IMAGE FILTER")
    print("  Detect and sort AI-generated images")
    print("="*60 + "\n")
    
    # Get source folder
    while True:
        source = input("Enter the SOURCE folder to scan: ").strip()
        source = source.strip('"').strip("'")  # Remove quotes if pasted
        if os.path.isdir(source):
            break
        print(f"  Error: '{source}' is not a valid folder. Try again.\n")
    
    # Get destination folder
    while True:
        dest = input("Enter the DESTINATION folder for AI images: ").strip()
        dest = dest.strip('"').strip("'")
        if dest:
            break
        print("  Error: Destination cannot be empty. Try again.\n")
    
    # Options
    print("\n--- Options ---")
    
    move_choice = input("Move or Copy files? (m/c) [m]: ").strip().lower()
    move = move_choice != 'c'
    
    recursive_choice = input("Scan subfolders recursively? (y/n) [n]: ").strip().lower()
    recursive = recursive_choice == 'y'
    
    print("\nConfidence levels:")
    print("  - low: Detect any AI signature (may have false positives)")
    print("  - medium: Require 2+ signatures (balanced)")
    print("  - high: Require 3+ signatures (very confident)")
    confidence = input("Minimum confidence level? (low/medium/high) [low]: ").strip().lower()
    if confidence not in ['low', 'medium', 'high']:
        confidence = 'low'
    
    # Confirm
    print(f"\n--- Confirm ---")
    print(f"Source: {source}")
    print(f"Destination: {dest}")
    print(f"Mode: {'Move' if move else 'Copy'}")
    print(f"Recursive: {'Yes' if recursive else 'No'}")
    print(f"Min Confidence: {confidence}")
    
    confirm = input("\nProceed? (y/n): ").strip().lower()
    if confirm != 'y':
        print("Operation cancelled.")
        return
    
    # Run the filter
    filter_ai_images(
        source_folder=source,
        ai_destination=dest,
        move=move,
        recursive=recursive,
        min_confidence=confidence,
        verbose=True
    )
    
    print("Done! Press Enter to exit...")
    input()


if __name__ == "__main__":
    main()
